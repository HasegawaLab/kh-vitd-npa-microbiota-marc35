---
title: "Serum 25OHD, NPA microbiome, and Severity in MARC-35"
author: "Kohei Hasegawa, MD, MPH"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
version
```

## Analysis
## 1. Uploading the packages
```{r Upload packages, message=FALSE}
library("tidyverse")
library("stringr")  # Work on string
library("cluster")
library("purrr")
library("tableone")
library("gplots")
library("lme4")     # for GLM
```

## 2. Uploading the microbiome dataset.  
```{r Upload the microbiome dataset}
genus_tbl <- read_csv("./data/m35_n1005_Genus_Table.csv") 
dim(genus_tbl)   # Row = 379 genera ; Col = 1005 subjects
#head(genus_tbl)
```

## 2.1. Create genus data by removing taxonomic ranks.
```{r Prep genus data}
# Combine OTU + genus variable
genus_tbl$otu = str_c(genus_tbl$X1, genus_tbl$Genus, sep="_")
head(genus_tbl$otu)

# Remove taxonomy -- the key is OTU + genus
genus_mat1 <- as.matrix(genus_tbl[,-c(1:7, 1013)])
rownames(genus_mat1) <- genus_tbl$otu # Genus(OTU code) as rowname

# Change to matrix
glimpse(genus_mat1) # Row = 379 genera, col = 1005 subjects
genus_mat <- t(genus_mat1) # Transpose
#glimpse(genus_mat) # Row = 1005 subjects, col = 379 genera, rownames=SampleID_NPA
```

## 2.2. Remove genus with 0 abundance.
```{r Remove genera with 0 abundance}
sum_abundance <- genus_mat %>% apply(., 2, sum) # Calculte sum for each genera
genus_zero_abundance <- sum_abundance==0 #indexing the genus with 0 abundance
which(genus_zero_abundance==TRUE)  # UncuB720_g has 0 value

genus_mat <- genus_mat[ ,genus_zero_abundance==FALSE] # Remove 1 genus
dim(genus_mat)    # rows=1005 subjects, cols=378 genera with abundance >= 0
```

## Optional: Codes that remove the genera with lowest variability (the lowerst quartile). 
Given the relatively small number of genera, we do **NOT** need to do this.
```{r Remove genera with low variability, eval=FALSE}
# Remove the genera with lowest variability (the lowest quartile).
sd_genus <- genus_mat %>% apply(., 2, sd) # Calculte SD for each genera
head(sd_genus)
 
q_sd <- quantile(sd_genus)
q_sd
q_sd[2]
ind_lowest_iqr_sd <- sd_genus < q_sd[2] #indexing the lowest quartile
genus_selected_mat <- genus_mat[,ind_lowest_iqr_sd==FALSE]
dim(genus_selected_mat)    # rows=1005 subjects, cols=290 genera with SD >= lowest quartile
```


## Optional: Scaling
```{r scaling, eval=FALSE}
# Check the sd of genera 
sd_abundance <- genus_mat %>% apply(., 2, sd) # Calculte sd for each genera
ggplot() + aes(sd_abundance) + geom_histogram(binwidth=0.01, colour="black", fill="white")
# Several OTUs have high SD, consider scaling.

# Scaling (pareto vs. auto) -- mixOmics default -- scaling = TRUE
   t_genus_mat <- t(genus_mat)
        dim(t_genus_mat)  # Transpose for scaling
        
   paretoscale <- function(z) {
            rowmean <- apply(z, 1, mean)        # row means
            rowsd <- apply(z, 1, sd)            # row standard deviation
            rowsqrtsd <- sqrt(rowsd)            # sqrt of sd
            rv <- sweep(z, 1, rowmean,"-")      # mean center
            rv <- sweep(rv, 1, rowsqrtsd, "/")  # divide by sqrtsd
            return(rv)
            }    
    autoscale <- function(z) {
            rowmean <- apply(z, 1, mean)        # row means
            rowsd <- apply(z, 1, sd)            # row standard deviation
            rv <- sweep(z, 1, rowmean,"-")      # mean center
            rv <- sweep(rv, 1, rowsd, "/")      # divide by sd
            return(rv)
    } 
# Apply scaling    
   genus_scaled_mat <- t(autoscale(t_genus_mat))
       dim(genus_scaled_mat)
```

## 2.4. Clearning sample ID and develop the final genus tbl
```{r Clearning sample ID}
microbiota_df<-as.data.frame(genus_mat)
#head(microbiota_df)
microbiota_df$SampleID_NPA <- rownames(genus_mat) # Create variable SampleID_NPA

# Remove extra text from SampleID_NPA:
microbiota_df$SampleID_NPA <- gsub(pattern = "^Mansbach.", replacement = "", x = microbiota_df$SampleID_NPA)
microbiota_df$SampleID_NPA <- gsub(pattern = ("B|C|A$") , replacement = "", microbiota_df$SampleID_NPA)

# Data not sorted -> Sort data:
microbiota_df<-microbiota_df %>% arrange(., by=SampleID_NPA)

# Genera data are changed to the tbl format.
microbiota_tbl <- microbiota_df %>% tbl_df()
rownames(microbiota_tbl) <- microbiota_tbl$SampleID_NPA #Set rownames
microbiota_tbl <- microbiota_tbl %>% select (-SampleID_NPA) #Remove SampleID_NPA
dim(microbiota_tbl) # rows=1005 subjects, cols=378
```


##2.3. Create OTU_genus data by removing taxonomic ranks.
```{r Finalize OTU_genus data}
otu_tbl <- genus_tbl %>% 
             filter(.$otu != "UncuB720_g") %>% # remove genus with zero abundance
             select(otu, 2:7)
colnames(otu_tbl)
rownames(otu_tbl) <- otu_tbl$otu # OUT_genus as rowname
dim(otu_tbl)
#View(otu_tbl)
```

## 3. Importing the metadata
```{r Import metadata, include=FALSE}
library("readstata13")
metadata <- read.dta13("./data/m35 _metadata_2018january_n1005.dta")
#colnames(metadata)
dim(metadata) # rows=1005 subjects, col = 174 variables
metadata_pam <- metadata %>% 
                  select (-c(study_id:enrolled_subj, site_region:site_region_lat,
                             mo12_solidfood, mo30_cat_0to1:mo30_farmanimal_0to1,
                             intch_lowestdoc_02sat:intch_hypertonic_saline,
                             inpatient_hfo:inpatient_hel,
                             Adenovirus:hMPVB_CT, myco_pneumoniae:hCoVHKU1,
                             RnaseP:RnaseP_CT, atopy_ISAC_food5:total_conc_ku_l_r)) %>%  # remove unnecessary variables
                  arrange(., by=SampleID_NPA)

# Making sure if the order of sample ID:s matches across the datasets
#metadata_pam$SampleID_NPA == rownames(microbiota_tbl) # Contain same sampleIDs in same order
unique(metadata_pam$SampleID_NPA == rownames(microbiota_tbl)) # TRUE


```

## 4. Recoding the metadata variables 
```{r Re-code metadata, message=FALSE}
# Covariates    
    # Age
        metadata_pam$Agecat2 <-NA
        metadata_pam$Agecat2[metadata_pam$Age_mo>=0 & metadata_pam$Age_mo <6] <- 1
        metadata_pam$Agecat2[metadata_pam$Age_mo>=6] <- 2
            metadata_pam$Agecat2 <- as.factor(metadata_pam$Agecat2)
            table(metadata_pam$Agecat2, useNA="ifany"); class(metadata_pam$Agecat2)   
        metadata_pam$Agecat3 <-NA
        metadata_pam$Agecat3[metadata_pam$Age_mo>=0 & metadata_pam$Age_mo <2] <- 1
        metadata_pam$Agecat3[metadata_pam$Age_mo>=2 & metadata_pam$Age_mo <6] <- 2
        metadata_pam$Agecat3[metadata_pam$Age_mo>=6] <- 3
            metadata_pam$Agecat3 <- as.factor(metadata_pam$Agecat3)
            table(metadata_pam$Agecat3, useNA="ifany"); class(metadata_pam$Agecat3)           
    # Sex  
        metadata_pam$female = metadata_pam$intake_sex
            table(metadata_pam$female, useNA="ifany"); class(metadata_pam$female)  
                
    # Race/ethnicity
        metadata_pam$raceethn <- as.factor(metadata_pam$raceethn)
            table(metadata_pam$raceethn, useNA="ifany"); class(metadata_pam$raceethn)  
    # Parental asthma (missing n=1)
        metadata_pam$parent_asthma = factor(metadata_pam$parent_asthma)
            table(metadata_pam$parent_asthma, useNA="ifany"); class(metadata_pam$parent_asthma)  
    # Maternal smoke  (missing n=1)
        metadata_pam$mata_smoke = factor(metadata_pam$mata_smoke)
            table(metadata_pam$mata_smoke, useNA="ifany"); class(metadata_pam$mata_smoke)          
    # Fall birth (Sep, Oct, Nov) -- https://www.ncbi.nlm.nih.gov/pubmed/18776151
        metadata_pam$birth_season <- factor(metadata_pam$birth_season)
            table(metadata_pam$birth_season, useNA="ifany"); class(metadata_pam$birth_season) 
        metadata_pam$fall_birth <- ifelse(metadata_pam$birth_season==3, TRUE, FALSE)
            table(metadata_pam$fall_birth, useNA="ifany"); class(metadata_pam$fall_birth)
    # Prematurity
        metadata_pam$premature37 <- factor(metadata_pam$premature37)
            table(metadata_pam$premature37, useNA="ifany"); class(metadata_pam$premature37)
    # Birth mode (1 missing)
        metadata_pam$mata_delivery <- factor(metadata_pam$mata_delivery)
            table(metadata_pam$mata_delivery, useNA="ifany"); class(metadata_pam$mata_delivery)
    # low birth wt  < 5 lb
        metadata_pam$intake_child_weight_born <- as.numeric(metadata_pam$intake_child_weight_born)
            table(metadata_pam$intake_child_weight_born, useNA="ifany");    class(metadata_pam$intake_child_weight_born)    
        metadata_pam$low_birth_wt <-NA
        metadata_pam$low_birth_wt[metadata_pam$intake_child_weight_born==1] <-TRUE
        metadata_pam$low_birth_wt[metadata_pam$intake_child_weight_born==2] <-TRUE
        metadata_pam$low_birth_wt[metadata_pam$intake_child_weight_born==3] <-FALSE
        metadata_pam$low_birth_wt[metadata_pam$intake_child_weight_born==4] <-FALSE    
            table(metadata_pam$low_birth_wt, useNA="ifany"); class(metadata_pam$low_birth_wt)
    # Previous breathing
        metadata_pam$prev_breathingprob2 <-NA
        metadata_pam$prev_breathingprob2[metadata_pam$prev_breathingprob==0] <-FALSE
        metadata_pam$prev_breathingprob2[metadata_pam$prev_breathingprob==1] <-TRUE
        metadata_pam$prev_breathingprob2[metadata_pam$prev_breathingprob==2] <-TRUE
            table(metadata_pam$prev_breathingprob2, useNA="ifany"); class(metadata_pam$prev_breathingprob2) 
    # H/o eczema 
        metadata_pam$intake_eczema_history <- factor(metadata_pam$intake_eczema_history)
            table(metadata_pam$intake_eczema_history, useNA="ifany"); class(metadata_pam$intake_eczema_history)   
    #Post-natal smoking exposure
        metadata_pam$intake_smoke <- factor(metadata_pam$intake_smoke)    
            table(metadata_pam$intake_smoke, useNA="ifany"); class(metadata_pam$intake_smoke) 
    # breastmilk_mostly_3mo (10 missing)
        metadata_pam$breastmilk_mostly_3mo <- factor(metadata_pam$breastmilk_mostly_3mo)    
            table(metadata_pam$breastmilk_mostly_3mo, useNA="ifany"); class(metadata_pam$breastmilk_mostly_3mo)            
            
        metadata_pam$breastmilk_mostly_3mo9 <-NA
        metadata_pam$breastmilk_mostly_3mo9[metadata_pam$breastmilk_mostly_3mo==0] <-0
        metadata_pam$breastmilk_mostly_3mo9[metadata_pam$breastmilk_mostly_3mo==1] <-1
        metadata_pam$breastmilk_mostly_3mo9[is.na(metadata_pam$breastmilk_mostly_3mo)]<-9        
            metadata_pam$breastmilk_mostly_3mo9 <- as.factor(metadata_pam$breastmilk_mostly_3mo9)
            table(metadata_pam$breastmilk_mostly_3mo9, useNA="ifany"); class(metadata_pam$breastmilk_mostly_3mo9) 
          
    # Corticosteroid use before the index hospitalization
        metadata_pam$corticosteroids_life <- as.factor(metadata_pam$corticosteroids_life)   
            table(metadata_pam$corticosteroids_life, useNA="ifany"); class(metadata_pam$corticosteroids_life)          
    # Corticosteroid use during the pre-hospitalization visit
        metadata_pam$corticosteroids_pre <- as.factor(metadata_pam$corticosteroids_pre)   
            table(metadata_pam$corticosteroids_pre, useNA="ifany"); class(metadata_pam$corticosteroids_pre)         
            
    # Wt at presentation
                    summary(metadata_pam$intch_weight)
        metadata_pam$intch_weight_cat2 = 
                    ifelse(metadata_pam$intch_weight<5.95,  "Low",
                    ifelse(metadata_pam$intch_weight>=5.95, "High",
                    NA))
            metadata_pam$intch_weight_cat2 <- as.factor(metadata_pam$intch_weight_cat2)
            table(metadata_pam$intch_weight_cat2, useNA="ifany"); class(metadata_pam$intch_weight_cat2)
            
            
    # sIgE (food or aero)
        metadata_pam$IgE_any_food <- as.factor(metadata_pam$IgE_any_food)   
            table(metadata_pam$IgE_any_food, useNA="ifany"); class(metadata_pam$IgE_any_food)  
        metadata$aeroallergens_atopy <- as.factor(metadata$aeroallergens_atopy)   
            table(metadata_pam$aeroallergens_atopy, useNA="ifany"); class(metadata_pam$aeroallergens_atopy)  
        metadata_pam$IgE_cat2 <- ifelse(metadata_pam$IgE_any_food==1 | metadata_pam$aeroallergens_atopy==1, TRUE,
                                    FALSE)
            table(metadata_pam$IgE_cat2, useNA="ifany"); class(metadata_pam$IgE_cat2) 
    # Virology        
        metadata_pam$RSVonly <- as.factor(metadata_pam$RSVonly)   
            table(metadata_pam$RSVonly, useNA="ifany"); class(metadata_pam$RSVonly)   
        metadata_pam$RVonly<- as.factor(metadata_pam$RVonly)   
            table(metadata_pam$RVonly, useNA="ifany"); class(metadata_pam$RVonly)         

        metadata_pam$RSVA <- as.factor(metadata_pam$RSVA)   
            table(metadata_pam$RSVA, useNA="ifany"); class(metadata_pam$RSVA)  
        metadata_pam$RSVB <- as.factor(metadata_pam$RSVB)   
            table(metadata_pam$RSVB, useNA="ifany"); class(metadata_pam$RSVB)
        metadata_pam$RSV <- as.factor(metadata_pam$RSV)   
            table(metadata_pam$RSV, useNA="ifany"); class(metadata_pam$RSV)   
        metadata_pam$RV  <- as.factor(metadata_pam$HRV)   
            table(metadata_pam$RV, useNA="ifany"); class(metadata_pam$HRV)  
            
        metadata_pam$OTHERvirus <-NA
            metadata_pam$OTHERvirus[metadata_pam$RSV==1 | metadata_pam$RV==1] <-FALSE    
            metadata_pam$OTHERvirus[metadata_pam$RSV !=1 & metadata_pam$RV !=1] <-TRUE
            table(metadata_pam$OTHERvirus, useNA="ifany"); class(metadata_pam$OTHERvirus)             
            
    # O2 sat (3 missing)
        metadata_pam$o2sat_initial <- as.factor(metadata_pam$o2sat_initial)   
            table(metadata_pam$o2sat_initial, useNA="ifany"); class(metadata_pam$o2sat_initial)  
    # Severity
        metadata_pam$CPAPintubate <- as.factor(metadata_pam$CPAPintubate)   
            table(metadata_pam$CPAPintubate, useNA="ifany"); class(metadata_pam$CPAPintubate)   
        metadata_pam$inpatient_location___3 <- as.factor(metadata_pam$inpatient_location___3)   
            table(metadata_pam$inpatient_location___3, useNA="ifany"); class(metadata_pam$inpatient_location___3)   
        metadata_pam$IntensiveTreatment <- as.factor(metadata_pam$IntensiveTreatment)   
            table(metadata_pam$IntensiveTreatment, useNA="ifany"); class(metadata_pam$IntensiveTreatment) 
        metadata_pam$LOS_dys <- as.integer(metadata_pam$LOS_dys)   
            summary(metadata_pam$LOS_dys, useNA="ifany"); class(metadata_pam$LOS_dys)      
        metadata_pam$LOS3dys <- as.factor(metadata_pam$LOS3dys)   
            table(metadata_pam$LOS3dys, useNA="ifany"); class(metadata_pam$LOS3dys)   
            
    # eos_4perc  (16 missing)
        metadata_pam$eos_4perc <- as.factor(metadata_pam$eos_4perc)   
            table(metadata_pam$eos_4perc, useNA="ifany"); class(metadata_pam$eos_4perc)          
    # Microbiota clusters (PAM 4)
        metadata_pam$PAM4_m35 = 
                    ifelse(metadata_pam$PAM4==1, "Moraxella dominant",
                    ifelse(metadata_pam$PAM4==2, "Haemophilus dominant",
                    ifelse(metadata_pam$PAM4==3, "Mixed",
                    ifelse(metadata_pam$PAM4==4, "Streptococcus dominant",
                    NA))))
          table(metadata_pam$PAM4_m35, useNA="ifany")         
 
    # site
        metadata_pam$site <- factor(metadata_pam$site)
            table(metadata_pam$site, useNA="ifany"); class(metadata_pam$site)  
    # Rec wheezing
          metadata_pam$recurrent_wheeze_sleep_36mo_cat <- factor(metadata_pam$recurrent_wheeze_sleep_36mo)
            table(metadata_pam$recurrent_wheeze_sleep_36mo_cat, useNA="ifany"); class(metadata_pam$recurrent_wheeze_sleep_36mo_cat)           #metadata_pam$recurrent_wheeze_36mo_cat <- factor(metadata_pam$recurrent_wheeze_36mo)
          #  table(metadata_pam$recurrent_wheeze_36mo_cat, useNA="ifany"); class(metadata_pam$recurrent_wheeze_36mo_cat)
          metadata_pam$ICSuse_36mo_cat <- factor(metadata_pam$ICSuse_36mo)
            table(metadata_pam$ICSuse_36mo_cat, useNA="ifany"); class(metadata_pam$ICSuse_36mo_cat)   
# Vitamin-D related compounds            
    # Total 25OHD
        summary(metadata_pam$vitd25_ngml)
        metadata_pam$vitd25_ngml_cat2 = 
                    ifelse(metadata_pam$vitd25_ngml <26.5,  "Low (<26.5 ng/ml)",
                    ifelse(metadata_pam$vitd25_ngml>=26.5, "High (>=26.5 ng/ml)",
                    NA))
            metadata_pam$vitd25_ngml_cat2 <- as.factor(metadata_pam$vitd25_ngml_cat2)
            table(metadata_pam$vitd25_ngml_cat2, useNA="ifany"); class(metadata_pam$vitd25_ngml_cat2)
    # Bioavailable vitD
        summary(metadata_pam$bioD)  # Unit = ng (same as vitd25)
                metadata_pam$bioD2 = 
                    ifelse(metadata_pam$bioD <4.2,  "Low (<4.2 ng/ml)",
                    ifelse(metadata_pam$bioD>=4.2, "High (>=4.2 ng/ml)",
                    NA))
            metadata_pam$bioD2 <- as.factor(metadata_pam$bioD2)
            table(metadata_pam$bioD2, useNA="ifany"); class(metadata_pam$bioD2)
    # Free vitD -- dichotomize vs. quartiles -- Unit = pg (10^-12)
        summary(metadata_pam$freeD)  
            metadata_pam$freeD2 = 
                    ifelse(metadata_pam$freeD <12.4,  "Low (<12.4 pg/ml)",
                    ifelse(metadata_pam$freeD>=12.4, "High (>=12.4 pg/ml)",
                    NA))
                metadata_pam$freeD2 <- as.factor(metadata_pam$freeD2)
                    table(metadata_pam$freeD2, useNA="ifany"); class(metadata_pam$freeD2)
    # D-binding protein (DBP)
        summary(metadata_pam$dbp_ugml)  # Unit = microG 
                metadata_pam$dbp2 = 
                    ifelse(metadata_pam$dbp_ugml <143.3,  "Low (<143.3 ug/ml)",
                    ifelse(metadata_pam$dbp_ugml>=143.3, "High (>=143.3 ug/ml)",
                    NA))
            metadata_pam$dbp2 <- as.factor(metadata_pam$dbp2)
            table(metadata_pam$dbp2, useNA="ifany"); class(metadata_pam$dbp2)      
```
                        
## 5. Exploratory analysis: Correlations of total 25OHD with free and bioavailable 25OHD
```{r Correlation with total with bioavailable}
# 1) with Free
    cor.test(metadata_pam$vitd25_ngml, metadata_pam$freeD, method="spearman")
    ggplot(metadata_pam, aes(x=vitd25_ngml, y=freeD)) +
        geom_point() +
        geom_smooth(method='loess')+
        coord_cartesian(xlim=c(0,50), ylim=c(0,50)) +
        labs(title ="B)", legend="tab",
            x="Serum total 25OHD level (ng/ml)", y="Serum free 25OHD level (pg/ml)") 
```
  
```{r Correlation with total with free}
# 2) with bioavailable
    cor.test(metadata_pam$vitd25_ngml, metadata_pam$bioD, method="spearman")
    ggplot(metadata_pam, aes(x=vitd25_ngml, y=bioD)) +
        geom_point() +
        geom_smooth(method='loess')+
        coord_cartesian(xlim=c(0,50), ylim=c(0,20)) +
        labs(title ="A)", 
            x="Serum total 25OHD level (ng/ml)", y="Serum bioavailable 25OHD level (ng/ml)")
```            


## 6. Table 1 
```{r Table 1, eval=TRUE}
    #colnames(metadata_pam)
    table1_tb <- metadata_pam %>% select (-c(intake_sex, HRV, genotype_RV, PAM4))  # For Table 1, remove some variables
    vars <- names(table1_tb)[-1]
    table1<-CreateTableOne(vars = vars, strata = c("vitd25_ngml_cat2"), 
                           data=table1_tb,
                           factorVars = c("female", "raceethn", 
                                         "parent_asthma", "mata_smoke",
                                         "birth_season", 
                                         "premature37","intake_child_weight_born", "mata_delivery",
                                         "prev_breathingprob2", "intake_eczema_history",
                                         "intake_smoke", "intake_daycare", "breastmilk_mostly_3mo",
                                         "corticosteroids_life", "corticosteroids_pre",
                                         "IgE_cat2", "IgE_any_food", "aeroallergens_atopy","eos_4perc",
                                         "RSVonly", "RVonly", "OTHERvirus",
                                         "RSV", "RV",
                                         "PAM4_m35",
                                         "o2sat_initial", 
                                         "CPAPintubate", "inpatient_location___3","IntensiveTreatment", "LOS3dys",
                                         "recurrent_wheeze_sleep_36mo_cat", "ICSuse_36mo_cat",
                                         "vitd25_ngml_cat2", "bioD2", "freeD2"
                                         ))
          print(table1, nonnormal = c("Age_mo", "intch_weight","LOS_dys",
                                       "intch_respiratory_rate",
                                      "RANTES_pgml","LL37_ngml", "vitd25_ngml", "bioD", "freeD", "dbp_ugml", 
                                      "RWsleep_time2event_36mo", "ICS_time2event_36mo"),
                            #exact = c("site"), 
                            smd = FALSE,
                            quote=TRUE, noSpaces = TRUE)         

```                     
  In Table 1, between the low and high total 25OH groups, there are significant differences in severity, alpha-diversity measures, and microbiota profiles (in PAM clusters that were developed previously -- see Hasegawa et at. Eur Respir J 2016).


## 7. Prepation for the analysis using MixOmics 
```{r Prep for MixOmics}
#1 X = microbiota data (X should be matrix)
  dataMatrix <- as.matrix(microbiota_tbl)
#2 Y = Metadata (limited)
      rownames(metadata_pam) <- metadata_pam$SampleID_NPA
  metadata_4vitd <- metadata_pam %>% select (vitd25_ngml, bioD, freeD, dbp_ugml)       
  metadata_3vitd <- metadata_pam %>% select (vitd25_ngml, bioD, freeD) #, dbp_ugml) 
  metadata_freeD <- metadata_pam %>% select (freeD) 
  metadata_total <- metadata_pam %>% select (vitd25_ngml) 
#3 Sanity check    
  #rownames(dataMatrix) %in% rownames(metadata_pam)   # TRUE confirmed
 
```


## 8. Loading mixOmics  (http://mixomics.org/).
Caution -- this package disables the dplyr "select" function.
```{r Upload mixOmics, message=FALSE}
library(mixOmics)  
```


## 9. PCA    
```{r PCA}
    X=dataMatrix
# Scree plot
    tune.pca(X, 
             ncomp  = 10,       # Plot the proportion of explained variance for min(n, p)principal components
             center = TRUE,     # Centering is a recommended transformation in most situations 
             scale  = TRUE)     # TRUE  = scaling to give similar weights to all genera in the analysis 
                                # if genera with high variance (with small abundance) be considered influential in PC
    pca_mixOmics <- pca(X, 
                        ncomp = 10, # First 2 components
                        center = TRUE,            
                        scale  = TRUE) 
# Individual plot
    ?plotIndiv
    plotIndiv(pca_mixOmics, 
              comp = c(1, 2), 
              ind.names = FALSE, 
              group   = metadata_pam$vitd25_ngml_cat2, # Grouping by serum total 25OHD level
              ellipse = TRUE,  
              legend  = TRUE, legend.title = "Serum total 25OHD level",
              title   = 'NPA microbiota proflies, PCA components 1 and 2')
```
  
  The PCA score plot shows an overlap of the OVERALL microbiota profile between the high and low 25OHD groups.



## 10. Correlation circle (variable) plot highlights clusters and show their contribution to each principal component.
```{r PCA Correlation circle plot}
      plotVar(pca_mixOmics, 
              comp = c(1, 2), 
              var.names = FALSE, 
              title = 'Correlation circle plot, PCA comp 1 - 2')  
```      

      

## 11. Partial Least Squares Discriminant Analysis (PLS-DA) -- Y should be binary.
For a discriminant analysis, we set the factor Y that indicates the total 25OH level (dichotomized by the median level) of each subject
```{r PLS-DA}
    X = dataMatrix    
    Y = metadata_pam$vitd25_ngml_cat2
# To evaluate the performance and the number of components necessary for the final model
    plsda_vitd25 <- plsda(X, 
                          Y, 
                          mode = "regression", 
                          ncomp = 5,  
                          scale = TRUE)  
```

## 11.1. Sample plot - The individuals are projected into the subspace spanned by the first 2 PLS-DA components. 
```{r PLS-DA sample plot}
        plotIndiv(plsda_vitd25, 
                  comp = 1:2,
                  rep.space= 'XY-variate', # the mean subspace in which coordinates are averaged from the first two subspaces (XY).
                  group = Y, 
                  col.per.group = c("orange", "royalblue1"),
                  style = 'ggplot2', alpha = 0.1, ind.names = FALSE,
                  #star = TRUE,
                  #ellipse = TRUE, ellipse.level =0.95, 
                  xlim = c(-10,20), ylim = c(-10, 10),  # coordinate ranges
                  legend = TRUE, legend.title = "Serum total 25OHD status", 
                  size.legend.title=10, size.legend=10,
                  size.xlabel =8, size.ylabel = 8,
                  title = "PLS-DA sample plot", size.title=10)
```
  
  There is some separation (and an overlap) of the two 25OHD groups compared to the unsupervised PCA sample plot. 
  Both PC 1 and 2 appear to give seperation of total 25OHD groups.
  


## 11.2. The prediction area is visualised by calculating a background surface first before overlaying the sample plot.
```{r PLS-DA projection}
  background = background.predict(plsda_vitd25, 
                                  comp.predicted=2, 
                                  dist = "max.dist") 
                    #optional: xlim = c(-40,40), ylim = c(-30,30))
  plotIndiv(plsda_vitd25, 
            comp = 1:2,
            group = Y, 
            ind.names = FALSE, title = "Maximum distance",
            col.per.group = c("orange", "royalblue1"),
            xlim = c(-10,20), ylim = c(-10, 10),  # coordinate ranges
            legend = TRUE, legend.title = "Serum total 25OHD level",
            background = background)   
```
    
## 11.3. Classification performance of the PLS-DA model is assessed with the perf function with 10-fold cross-validation repeated 100 times. 
```{r PLS-DA classification performance}
        set.seed(1) # for reproducibility, only when the `cpus' argument is not used
  perf_plsda_vitd25<- perf(plsda_vitd25, 
                          validation = "Mfold", folds = 10, # 10-fold cross-validation
                          nrepeat = 50, # for an accurate estimation, 50-100 repeats
                          progressBar = FALSE, 
                          auc = TRUE)   # AUC calculation for later
  perf_plsda_vitd25$error.rate  
```

## 11.4. Performance plot: the optimal number of components based on t-tests that test for a significant difference in the mean error rate between components
```{r PLS-DA performance plot}
  plot(perf_plsda_vitd25, 
      col = color.mixo(5:7), 
      sd = TRUE, # *ncomp = 2 has lowest error rate (centroids.dist)
      legend.position = "horizontal")  
   ## Outputs 
        perf_plsda_vitd25$choice.ncomp 
```
  
  From the performance plot, the overall error rate and the Balanced Error Rate (BER) are similar and lower with the number of components of 2.  

## 11.5. AUC plot: AUC is calculated from training cross-validation sets and averaged.
```{r AUC plot}
  auc.plsda = auroc(plsda_vitd25, 
                    roc.comp = 1:2)  # Number of components in the model
```




## 13. Sparse PLS-DA
PLS-DA is built on all genera, many of which may be uninformative to characterize the different groups. 
By contrast, sPLS-DA analysis aims to identify a small subset of genera that best discriminate the classes.  

## 13.1. First to estimate the classification performance (error rates) with respect to the number of selected variables in the model with the use of tune function
```{r sPLS-DA Training, warning=FALSE}
# Grid of possible keepX values that will be tested for each component
  list.keepX <- seq(5, 50, by=5)
# Number of variables in keepX to select  
        library("snow") # For parallel computing
        set.seed(0)
  tune_plsda_vitd25<-tune.splsda(X, Y, 
                            ncomp = 2, # Chosen from the PLS-DA above 
                            test.keepX = list.keepX,
                            validation = 'Mfold', folds = 10, nrepeat = 10, 
                            dist = 'max.dist', 
                            measure = "BER",
                            scale=TRUE,
                            progressBar = FALSE, 
                            cpus = 8)  # Change the number of parallel CPUs to speed up
  
## error rate per component for the keepX grid     
  error <- tune_plsda_vitd25$error.rate  
## The number of optimal components to choose 
  ncomp <- tune_plsda_vitd25$choice.ncomp$ncomp # optimal number of components based on t-tests
     #ncomp
## The optimal number of features to select on each component  
  select.keepX <- tune_plsda_vitd25$choice.keepX[1:2]  
      select.keepX
  plot(tune_plsda_vitd25, col = color.jet(2))
```
  
  
  A number of 2 components is sufficient for our final sPLS-DA model to reach optimal performance. The number of genera in the sparse model would be 5-20.


## 13.2. SPLS-DA final model.
The final model includes 2 components with 10-20 and 10-20 (these numbers can be flexible) selected variables on the components.
```{r sPLS-DA FINAL model}
splsda_vitd25 <- splsda(X, Y, 
                        ncomp = 2,  # from the results above
                        mode = "regression",
                        scale = TRUE,
                        keepX = c(20,20))  
```

## 13.3. SPLS-DA Sample plot
```{r sPLS-DA FINAL Sample plot}
  plotIndiv(splsda_vitd25, 
            comp = c(1,2),
            rep.space= 'XY-variate', 
            group = Y,
            col.per.group = c("orange", "royalblue1"),
            ind.names = FALSE, 
            ellipse = TRUE,   ellipse.level =0.95,
            #star = TRUE,
            xlim = c(-5,5), ylim = c(-3, 6),  # coordinate ranges
            legend = TRUE, legend.title = "Serum total 25OHD status", 
            size.legend.title=10, size.legend=10,
            style = 'ggplot2', alpha = 0.1, 
            title = 'sPLS-DA, comp 1 & 2', size.title=10,
            size.xlabel =8, size.ylabel = 8)
```


## 13.4. sPLS-DA AUC plot
```{r sPLS-DA AUC plot}
  auc.splsda = auroc(splsda_vitd25, roc.comp = 2)
```

## 13.5. Classification performance assessment of the final sPLS-DA model with 5 cross-validation repeated 50-100 times.
```{r Final sPLS-DA model, warning=FALSE}
     set.seed(1) # for reproducibility
   perf.splsda <- perf(splsda_vitd25, 
                       validation = "Mfold", folds = 5, nrepeat=50, #50-100 repeats recommended
                       dist = "all", 
                       progressBar = FALSE,
                       cpus = 8) # parallel computing    
    perf.splsda$error.rate
    plot(perf.splsda) 
```


## 13.6. Examinining the stability of the variables selected across the different cross-validation folds. 
(e.g., if 100%, the genus is selected in all cross-validation folds)
```{r sPLS-DA stability}
# Each variable's stability that is selected across the CV runs is represented with a vertical bar   
      par(mfrow=c(1,2))
  plot(perf.splsda$features$stable[[1]], type = 'h', ylab = 'Stability', 
       xlab = 'Features', main = 'Component 1', las =2)
  plot(perf.splsda$features$stable[[2]], type = 'h', ylab = 'Stability', 
       xlab = 'Features', main = 'Component 2', las =2)
      par(mfrow=c(1,1))     
# Outputs the selected variables along with their loading weight value
# Component 1      
    ## Here we match the selected variables to the stable features
       ind.match = match(selectVar(splsda_vitd25, comp = 1)$name, 
                                  names(perf.splsda$features$stable[[1]]))
    ## Extract the frequency of selection of those selected variables
       Freq = as.numeric(perf.splsda$features$stable[[1]][ind.match])
       data.frame(selectVar(splsda_vitd25, comp = 1)$value, Freq)    
   
# Component 2
      ind.match = match(selectVar(splsda_vitd25, comp = 2)$name, 
                                  names(perf.splsda$features$stable[[2]]))
       Freq = as.numeric(perf.splsda$features$stable[[2]][ind.match])
       data.frame(selectVar(splsda_vitd25, comp = 2)$value, Freq)  
```


## 13.7. sPLS-DA loading plots
```{r sPLS-DA loading plot for comp 1, eval=FALSE}
  plotLoadings(splsda_vitd25, 
               comp = 1, 
               title = 'Loadings on comp 1', 
               contrib = 'max', 
               method = 'mean')  
```

```{r sPLS-DA loading plot for comp 2, eval=FALSE}
  plotLoadings(splsda_vitd25, 
               comp = 2,
               title = 'Loadings on comp 2', 
               contrib = 'max', 
               method = 'mean') 
```

## 13.8. sPLS-DA heatmap
```{r sPLS-DA heatmap, fig.height=7, fig.width=7, eval=FALSE}
# Prep for the grouping (color) by patient class        
    heatmap_df <- data.frame(study_id = rownames(metadata_pam),   # You need study ID in the data
                             vitd25_ngml_cat2 = metadata_pam$vitd25_ngml_cat2)
    patient.col <- c("orange", "blue")[heatmap_df$vitd25_ngml_cat2]   
## The final metabolomics signature is plotted (default values to Euclidian distance and Complete linkage).
  cim(mat = splsda_vitd25, 
      comp = 1:2,
      mapping = "XY",
      transpose = TRUE,
      dist.method = c("euclidean", "euclidean"),
      clust.method = c("centroid", "centroid"),
      cluster = "both",
         xlab="Patients",
         ylab="Genera",
      row.sideColors = patient.col, row.names = TRUE,
         title ="Component 1",
         legend=list(title="Serum total 25OHD status"),
         margins =c(10,20))   # The color is the SCALED intensity of metabolite in each person
          
```
  
 

## 13.9. Get the loading vectors from PLS-DA model. These will be used for the regression later.
```{r Loading vectors from PLS-DA}
loading_PLSDA <-as.data.frame(splsda_vitd25$loadings[[1]]) 
        loading_PLSDA$metabolite <- rownames(loading_PLSDA)  # Add a row for metabolites
        index1 <- loading_PLSDA["comp 1"] !=0   # Index the selected metabolites from comp 1
        index2 <- loading_PLSDA["comp 2"] !=0   # Index the selected metabolites from comp 2
loading_PLSDA_comp1 <- loading_PLSDA$metabolite[index1==TRUE] # Get the selected metabolite names
        print (loading_PLSDA_comp1)
loading_PLSDA_comp2 <- loading_PLSDA$metabolite[index2==TRUE]
        print (loading_PLSDA_comp2)
intersect(loading_PLSDA_comp1, loading_PLSDA_comp2)
```





## 14. Partial Least Squares (PLS) regrssion.  Instead of the dichotomised total 25OHD levels used in the PLS-DA analysis above (which loses the informaiton of continous variable), here we use the continous values of serum 25OHD levels in an attempt to explain the 25OHD levels with respect to the genus abundances   

First, we used PLS and then followed with the sparse variation sPLS for comparison. 
```{r PLS}
    X = dataMatrix
    Y = metadata_total   #total 25OHD only
    Y3= metadata_3vitd   # 3 compounds
    Y4= metadata_4vitd   # 4 compounds
# The first step is to tune the key parameters by using perf().
    npa_pls <- pls(X, 
                   Y, 
                   ncomp = 10, 
                   mode = "regression",
                   scale  = TRUE)
    #Tune function cannot be used for the canonical mode
          set.seed(1)
    tune.pls <- perf(npa_pls,       
                     validation = "Mfold", folds = 10,     # 10-fold cross validation x 100 times
                     nrepeat = 100,
                     progressBar = FALSE) 

    plot(tune.pls$Q2.total)  # Q2.total to tune the number of components 
        #abline(h=0.0975)   # The rule of thumbs is that a PLS component should be included in the model if its value >= 0.0975.
        tune.pls$Q2.total
```


## 15. Sparse PLS (sPLS). 
sPLS combines both integration and variable selection to maximize the covariance between two data sets and to identify latent variables. 
```{r sparse PLS}
    #ncomp=ncol(Y) # When canonical mode is used, the num of components is <= ncol(Y) (number of variables in Y)
    ncomp=2
    npa_spls <- spls(X, 
                     Y, 
                ncomp = ncomp,                  
                keepX = c(20,20),  # I would choose 10-20 for each
                keepY = rep(ncol(Y),  length=ncomp),   
                scale = TRUE,
                mode = "regression")  # Options: "regression", "canonical", "invariant", "classic"
```

## Perf function -- not for cannoical mode.
```{r sPLS perf -- Not used for cannonical mode, eval=FALSE}
      set.seed(1)  
    tune.spls <- perf(npa_spls, 
                      validation = "Mfold", folds = 10, 
                      progressBar = FALSE, 
                      dist = 'max.dist',
                      nrepeat = 100)
    plot(tune.spls$Q2.total)
        abline(h = 0.0975)
    tune.spls$Q2.total  
```


## 15.1. sPLS sample plot represents the samples projected onto the sPLS components.
```{r sPLS Sample plot}
    plotIndiv(npa_spls, comp = c(1,2), 
              rep.space= 'XY-variate', 
              group = metadata_pam$vitd25_ngml_cat2,
              col.per.group = c("orange", "royalblue1"),
              style = 'ggplot2', alpha = 0.1, ind.names = FALSE,
                  #star = TRUE,
                  #ellipse = TRUE, ellipse.level = 0.95,
                  xlim = c(-5,6), ylim = c(-10,10),
                  legend = TRUE, legend.title = "Serum total 25OHD status", 
                  size.legend.title=10, size.legend=10,
                  size.xlabel =8, size.ylabel = 8,
                  title = "Sample plot of sPLS", size.title=0)
```   
  
  Each dot represents the global serum genus profile of a single patient by plotting the component scores in the smaller subspace spanned by latent variables of sPLS model. The scatter plot indicates the similarities and dissimilarities in the global microbiota profile between patients, grouped by serum total 25OHD levels (defined by the median values). 
  

## 15.2. sPLS loading plot:
```{r sPLS Loading plot comp 1, fig.height=5, fig.width=10, eval=TRUE}
  plotLoadings(npa_spls, 
               comp = 1, 
               title = 'Loadings on comp 1', 
               contrib = 'max', 
               method = 'mean') 
```
```{r sPLS Loading plot comp2, fig.height=5, fig.width=10, eval=TRUE}
  plotLoadings(npa_spls, 
               comp = 2, 
               title = 'Loadings on comp 2', 
               contrib = 'max', 
               method = 'mean')  

```
```{r Integrated loading plot, eval=FALSE}
# First unload mixOmics and upload dplyr to use the "select" function
      detach("package:mixOmics", unload=TRUE)
      detach("package:dplyr",    unload=TRUE)
      library(dplyr); library(broom)
# Get loading values
    loading_spls <-as.data.frame(npa_spls$loadings[[1]]) 
    loading_spls$metabolite <- rownames(loading_spls)  # Add a row for metabolites

    loadings_1 <- loading_spls %>% 
                    filter(.["comp 1"] != 0) %>%
                    select(c(1,4)) %>%               
                    rename("loading" = "comp 1")
    loadings_2 <- loading_spls %>% 
                    filter(.["comp 2"] != 0) %>%
                    select(c(2,4)) %>%               
                    rename("loading" = "comp 2")
    loadings_tbl <- rbind(loadings_1, loadings_2) %>% arrange(abs(loading)) %>% tbl_df()
    loadings_tbl[["sign"]] = ifelse(loadings_tbl[["loading"]] >= 0, "positive", "negative")
# ggplot
    loadings_tbl %>%
        ggplot(aes(x=reorder(metabolite, abs(loading)), y=loading, fill=sign)) +
        geom_bar(stat= "identity") +
        scale_fill_manual(values = c("positive" = "orange", "negative" = "royalblue1")) +
        coord_flip() +
        xlab("Metabolite") + ylab("Loading")
```
  
  The plot represents the loading coefficient of top genera that were selected from the sPLS regression model. 


## 15.3. Heatmap 
```{r sPLS heatmap 1, fig.height=7, fig.width=8}
# Heatmap 1
  library(mixOmics)
  cim(mat=npa_spls, 
      comp = 1:2, 
      #transpose= TRUE,
      dist.method = c("euclidean","euclidean"),
      clust.method = c("average", "average"),
      cluster = "row",
      col.cex = NULL,
      row.cex = NULL,
      #threshold = 0.3,
          xlab = "Serum vitamin D compounds", 
          ylab = "Serum metabolome (selected metabolites)", 
          margins = c(7, 18)) 
```
  


```{r sPLS heatmap 2,  fig.height=5, fig.width=9, eval=FALSE}
# Heatmap 2
  # Prep for the grouping (color) by patient class        
    heatmap_df <- data.frame(study_id = rownames(metadata_pam),   # You need study ID in the data
                             vitd25_ngml_cat2 = metadata_pam$vitd25_ngml_cat2)
    patient.col <- c("orange", "blue")[heatmap_df$vitd25_ngml_cat2]   
  # heatmap
   cim(mat=npa_spls, 
      comp = 1:2, 
      mapping = "X",
      transpose= TRUE,
      dist.method = c("euclidean","euclidean"),
      clust.method = c("complete", "complete"),
      cluster = "both",
         ylab="Selected metabolites",
         xlab="Patients",
      row.sideColors = patient.col, row.names = TRUE,
         title ="Component 1",
         #legend=list(title="Serum total 25OHD status"),
         margins =c(10,20))   # The color is the SCALED intensity of metabolite in each person

```      

## 15.4. network
```{r sPLS network, fig.height=5, fig.width=5, eval=FALSE}
      color.edge <- color.GreenRed(50)
  network(npa_spls, comp=1:2,
          shape.node = c("rectangle", "rectangle"),
          color.node = c("white", "pink"),
          color.edge = color.edge)
```

## 15.5. Get the loading data from sPLS model
```{r Get laoding vectors from sPLS}
loading_spls <-as.data.frame(npa_spls$loadings[[1]]) 
        loading_spls$metabolite <- rownames(loading_spls)  # Add a row for metabolites
        index1 <- loading_spls["comp 1"] !=0   # Index the selected metabolites from comp 1
        index2 <- loading_spls["comp 2"] !=0   # Index the selected metabolites from comp 2
loading_sPLS_comp1 <- loading_spls$metabolite[index1==TRUE] # Get the selected metabolite names
        print (loading_sPLS_comp1)
loading_sPLS_comp2 <- loading_spls$metabolite[index2==TRUE]
        print (loading_sPLS_comp2)
intersect(loading_sPLS_comp1, loading_sPLS_comp2)
```


## 16.  Random forest. 
```{r random forrest}
library(randomForest); library(caret)
# Make training dataset
  microbiota_tbl_rf <- microbiota_tbl
  microbiota_tbl_rf$SampleID_NPA <- rownames(microbiota_tbl) %>% as.integer()
  microbiota_tbl_rf <- metadata_pam %>% 
                            select(SampleID_NPA, vitd25_ngml_cat2) %>%
                            inner_join(., microbiota_tbl_rf, by="SampleID_NPA") %>%
                            select(-SampleID_NPA)
  rownames(microbiota_tbl_rf) <- rownames(microbiota_tbl)

# Parallel computing
    library("doMC")        
    registerDoMC(cores = 8) ## All subsequent models are then run in parallel
# Fit random forrest  
  set.seed(1)
  rf_fit <- train(vitd25_ngml_cat2 ~.,  # by specifing ".", enter all genera
                  data=microbiota_tbl_rf,
                  method="rf", 
                  #preProcess = c('center', 'scale'),
                  tuneLength = 3,  # Try 3 different values for each parameter
                  trControl = trainControl(method = "cv", number = 10), # 10-fold Cross validation
                  prox=TRUE) 
  rf_fit
# Check the variable importance 
  varImp(rf_fit, scale=FALSE)
```




## 17. Regression models: Here we examine the association between the each of the 20 selected 25OHD-related genera and the risk of positive pressure ventilation (PPV) use, the clincial outcome.  
```{r}

```




